/*
 * The MIT License (MIT)
 * Copyright 2014 Owen Rubel
 *
 * IO State (tm) Owen Rubel 2014
 * API Chaining (tm) Owen Rubel 2013
 *
 *   https://opensource.org/licenses/MIT
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the Software
 * is furnished to do so, subject to the following conditions:
 *
 * The above copyright/trademark notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
 * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
 * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
 * THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

package net.nosegrind.apiframework

import grails.config.Config
import grails.core.support.GrailsConfigurationAware
import net.nosegrind.apiframework.comm.ApiRequestService
import net.nosegrind.apiframework.comm.ApiResponseService
import org.springframework.beans.factory.annotation.Autowired

import javax.servlet.http.HttpServletResponse


class TracerouteInterceptor implements GrailsConfigurationAware{

    int order = HIGHEST_PRECEDENCE + 996

	ApiRequestService apiRequestService
	ApiResponseService apiResponseService
	ApiDomainService apiDomainService
	ApiCacheService apiCacheService
	TimerService timerService


	void setConfiguration(Config cfg) {
		//String apiVersion =
		String entryPoint = "t${cfg.info.app.version}"
		match(uri:"/${entryPoint}/**")
	}

	boolean before(){
		//println("##### FILTER (BEFORE)")
		timerService.clearTimer()
		timerService.startTime('TracerouteInterceptor','before')

		params.format = request.format.toUpperCase()

		Map methods = ['get':'show','put':'update','post':'create','delete':'delete']
		try{
			//if(request.class.toString().contains('SecurityContextHolderAwareRequestWrapper')){
				timerService.startTime('ApiCacheService','getApiCache')
				LinkedHashMap cache = (params.controller)?apiCacheService.getApiCache(params.controller):[:]
				timerService.endTime()

				if(cache){
					params.apiObject = (params.apiObjectVersion)?params.apiObjectVersion:cache['currentStable']['value']
					if(!params.action){ 
						String methodAction = methods[request.method.toLowerCase()]
						if(!cache[params.apiObject][methodAction]){
							params.action = cache[params.apiObject]['defaultAction']
						}else{
							params.action = methods[request.method.toLowerCase()]
							
							// FORWARD FOR REST DEFAULTS WITH NO ACTION
							List tempUri = request.getRequestURI().split("/")
							if(tempUri[2].contains('dispatch') && "${params.controller}.dispatch" == tempUri[2] && !cache[params.apiObject]['domainPackage']){
								forward(controller:params.controller,action:params.action,params:params)
								timerService.endTime('TracerouteInterceptor','before')
								return false
							}
						}
					}
							
					// SET PARAMS AND TEST ENDPOINT ACCESS (PER APIOBJECT)
					timerService.startTime('ApiRequestService','handleApiRequest')
					boolean result = apiRequestService.handleApiRequest(cache,request,params)
					timerService.endTime()

					//HANDLE DOMAIN RESOLUTION
					if(cache[params.apiObject]['domainPackage']){
						// SET PARAMS AND TEST ENDPOINT ACCESS (PER APIOBJECT)
						if(result){
							def model
							switch(methods[request.method.toLowerCase()]){
								case 'show':
									timerService.startTime('ApiDomainService','showInstance')
									model = apiDomainService.showInstance(cache,params)
									timerService.endTime()
									break
								case 'update':
									timerService.startTime('ApiDomainService','updateInstance')
									model = apiDomainService.updateInstance(cache,params)
									timerService.endTime()
									break
								case 'create':
									timerService.startTime('ApiDomainService','createInstance')
									model = apiDomainService.createInstance(cache,params)
									timerService.endTime()
									break
								case 'delete':
									timerService.startTime('ApiDomainService','deleteInstance')
									model = apiDomainService.deleteInstance(cache,params)
									timerService.endTime()
                                    if(!model) {
                                        model = [:]
                                    }
									break
							}

							if(!model && request.method.toLowerCase()!='delete'){
								render(status:HttpServletResponse.SC_BAD_REQUEST)
								timerService.endTime('TracerouteInterceptor','before')
								return false
							}

							timerService.startTime('ApiResponseService','formatDomainObject')
							def newModel = apiResponseService.formatDomainObject(model)
							timerService.endTime()

							timerService.startTime('ApiResponseService','handleApiResponse')
							LinkedHashMap content = apiResponseService.handleApiResponse(cache,request,response,newModel,params)
							timerService.endTime()

							if(request.method.toLowerCase()=='delete' && content.apiToolkitContent==null){
								render(status:HttpServletResponse.SC_OK)
								timerService.endTime('TracerouteInterceptor','before')
								return false
							}else{
								render(text:content.apiToolkitContent, contentType:"${content.apiToolkitType}", encoding:content.apiToolkitEncoding)
								timerService.endTime('TracerouteInterceptor','before')
								return false
							}
						}
						//return result
					}else{
						timerService.endTime('TracerouteInterceptor','before')
						return result
					}
				}
			//}
			timerService.endTime('TracerouteInterceptor','before')
			return false

		}catch(Exception e){
			log.error("[ApiToolkitFilters :: preHandler] : Exception - full stack trace follows:", e);
			timerService.endTime('TracerouteInterceptor','before')
			return false
		}
	}

	boolean after(){
		//println("##### FILTER (AFTER)")
		timerService.startTime('TracerouteInterceptor','after')
		try{
			if(!model){
				render(status:HttpServletResponse.SC_BAD_REQUEST)
				timerService.endTime('TracerouteInterceptor','after')
				LinkedHashMap timerResponse = timerService.getTimer(params)
				render(text:timerResponse.apiToolkitContent, contentType:"${timerResponse.apiToolkitType}", encoding:timerResponse.apiToolkitEncoding)
				return false
			}

			timerService.startTime('ApiResponseService','convertModel')
			Map newModel = (model)?apiResponseService.convertModel(model):model
			timerService.endTime()

			timerService.startTime('after:ApiCacheService','getApiCache')
			LinkedHashMap cache = (params.controller)?apiCacheService.getApiCache(params.controller):[:]
			timerService.endTime()

			LinkedHashMap content = apiResponseService.handleApiResponse(cache,request,response,newModel,params)
				
			if(content){
                render(text:content.apiToolkitContent, contentType:"${content.apiToolkitType}", encoding:content.apiToolkitEncoding)
				timerService.endTime('TracerouteInterceptor','after')
				LinkedHashMap timerResponse = timerService.getTimer(params)
				render(text:timerResponse.apiToolkitContent, contentType:"${timerResponse.apiToolkitType}", encoding:timerResponse.apiToolkitEncoding)
				return false
			}
			timerService.endTime('TracerouteInterceptor','after')
			LinkedHashMap timerResponse = timerService.getTimer(params)
			render(text:timerResponse.apiToolkitContent, contentType:"${timerResponse.apiToolkitType}", encoding:timerResponse.apiToolkitEncoding)
			return false
	   }catch(Exception e){
			log.error("[ApiToolkitFilters :: apitoolkit.after] : Exception - full stack trace follows:", e);
			timerService.endTime('TracerouteInterceptor','after')
			LinkedHashMap timerResponse = timerService.getTimer(params)
			render(text:timerResponse.apiToolkitContent, contentType:"${timerResponse.apiToolkitType}", encoding:timerResponse.apiToolkitEncoding)
			return false
	   }

	}
}

